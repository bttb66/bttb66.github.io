{"data":{"site":{"siteMetadata":{"title":"SW_P","author":"BTTB66"}},"markdownRemark":{"id":"3d8f9ebf-68e0-5482-8260-15d9c82634cc","html":"<h2>1. Component</h2>\n<p>리액트는 ui를 재사용 가능한 <strong>컴포넌트</strong> 단위로 분리하여 작성합니다. 다시 말하면, 리액트의 모든 것은 컴포넌트 입니다!</p>\n<p>컴포넌트는  render 메소드에서  <a href=\"https://reactjs.org/docs/introducing-jsx.html\">JSX</a>를 통하여 작성된<strong>단 하나</strong>의 DOM element만을 반환해야합니다.</p>\n<p>예를 들면,</p>\n<div class=\"gatsby-highlight\" data-language=\"react\">\n      <pre class=\"language-react\"><code class=\"language-react\">const ex1 = (\n\t&lt;div&gt; element1 &lt;/div&gt;\n\t&lt;div&gt; element2 &lt;/div&gt;\n);</code></pre>\n      </div>\n<p>이러한 경우 <em>JSX elements must be wrapped in an enclosing tag</em> 와같은 에러를 뱉어냅니다.</p>\n<p>따라서,</p>\n<div class=\"gatsby-highlight\" data-language=\"react\">\n      <pre class=\"language-react\"><code class=\"language-react\">const ex1 = (\n\t&lt;div&gt;\n        &lt;div&gt; element1 &lt;/div&gt;\n        &lt;div&gt; element2 &lt;/div&gt;\n\t&lt;/div&gt;\n);</code></pre>\n      </div>\n<p>이렇게 다른 태그로 감싸거나, <a href=\"https://reactjs.org/docs/fragments.html#keyed-fragments\">Fragment</a>를 활용해야 합니다.</p>\n<h3>1) 클래스형 컴포넌트</h3>\n<p>컴포넌트를 작성하는 방식은 클래스형 컴포넌트, 함수형 컴포넌트 2가지가 있습니다.</p>\n<p>먼저, 클래스형 컴포넌트에는 JSX로 이루어진 DOM Element를 반환하는 <strong>render</strong>함수가 꼭 있어야합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"react\">\n      <pre class=\"language-react\"><code class=\"language-react\">import React, { Component } from &#39;react&#39;;\n\nclass Hello extends Component {\n    render(){\n        return(\n            &lt;div className=&quot;Hello&quot;&gt;\n                &lt;h1&gt; Hello, BTTB66! &lt;/h1&gt;\n            &lt;/div&gt;\n        );\n    }\n}\n\nexport default Hello;</code></pre>\n      </div>\n<p>클래스형 컴포넌트는 props와 state, life-cycle 관련 메소드 모두 활용 가능합니다.</p>\n<h3>2) 함수형 컴포넌트</h3>\n<p>함수형 컴포넌트는 props만 사용이 가능합니다. state와 life-cycle 모두 활용할 수 없지만, 클래스형 컴포넌트에 비하여 속도가 빠르다는 장점이 있습니다. </p>\n<p>따라서, state나 life-cycle을 활용하지 않고 <strong>자체기능 없이 그저 전달된 props만 렌더링 하는 경우</strong>에는 함수형 컴포넌트를 활용하는 것이 좋습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"react\">\n      <pre class=\"language-react\"><code class=\"language-react\">import React from &#39;react&#39;;\n\n/*비구조 할당방식 활용*/\ncont Hello = ({name})=&gt;{\n    return(\n        &lt;div className=&quot;Hello&quot;&gt;\n            &lt;h1&gt; Hello, {name}! &lt;/h1&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default Hello;</code></pre>\n      </div>\n<p>함수형 컴포넌트 활용시, 함수의 매개밴수를 통하여 props에 접근 가능합니다.</p>\n<h2>2. Props, state</h2>\n<p>리액트의 컴포넌트에서 다루는 데이터는 props와 state 이 2가지로 나누어집니다.  간단히 설명하면, props는 부모로부터 전해받는 변경이 불가능한 데이터 입니다. 이와 달리, state는 컴포넌트의 내부에서 선언하며, 변경이 가능합니다.</p>\n<h3>1) props</h3>\n<div class=\"gatsby-highlight\" data-language=\"react\">\n      <pre class=\"language-react\"><code class=\"language-react\">import React, { Component } from &#39;react&#39;;\n\nclass Hello extends Component {\n    render(){\n        cont { name } = this.props;\n        return(\n            &lt;div className=&quot;Hello&quot;&gt;\n                &lt;h1&gt; Hello, {name}! &lt;/h1&gt;\n            &lt;/div&gt;\n        );\n    }\n}\n\nexport default Hello;</code></pre>\n      </div>\n<p>부모로부터 전달받은 props값은 this키워드를 통하여 접근이 가능합니다. 위의 예제에서는 비구조할당 방식을 활용하여 props의 name에 접근하였습니다.</p>\n<p>이러한 props는 아래와 같은 방식으로 전달할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"react\">\n      <pre class=\"language-react\"><code class=\"language-react\">import React, {Component} from &#39;react&#39;;\nimport Hello from &#39;./Hello&#39;;\n\nclass App extends Component{\n    render(){\n        return (\n        \t&lt;Hello name=&quot;BTTB66&quot; /&gt;\n        );\n    }\n}\n\nexport default App;</code></pre>\n      </div>\n<p>만약, 부모 컴포넌트에서 props 데이터를 실수로 전달하지 않을 경우, 자식 컴포넌트에서 props에 접근하면 오류가 발생합니다.</p>\n<p>이러한 오류를 막기 위하여 아래와 같이 <strong>default props</strong>를 설정해주어야 합니다!</p>\n<div class=\"gatsby-highlight\" data-language=\"react\">\n      <pre class=\"language-react\"><code class=\"language-react\">import React, { Component } from &#39;react&#39;;\n\nclass Hello extends Component {\n    static defaultProps= {\n        name: &#39;이름&#39;\n    }\n    render(){\n        return(\n            &lt;div className=&quot;Hello&quot;&gt;\n                &lt;h1&gt; Hello, BTTB66! &lt;/h1&gt;\n            &lt;/div&gt;\n        );\n    }\n}\n\nexport default Hello;</code></pre>\n      </div>\n<h3>2) state</h3>\n<p>props와 달리, 동적인 데이터를 다루어야할 경우 state를 활용할 수 있습니다. </p>\n<p>state를 사용할 경우, class field를 활용하면 훨씬 편리해집니다. 때문에 EcmaScript6의 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes\">class field</a>에 대한 이해가 선행되는 것이 좋습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"react\">\n      <pre class=\"language-react\"><code class=\"language-react\">import React, { Component } from &#39;react&#39;;\n\nclass Count extends Component {\n    //state 정의\n    state = {\n        num : 0\n    }\n\t\n    handleIncrease = () =&gt; {\n        this.setState((prevState) =&gt; {\n            return {\n                number: ++prevState.num\n            };\n        });\n    }\n\n    handleDecrease = () =&gt; {\n        this.setState((prevState) =&gt; {\n            return {\n                number: --prevState.num\n            };\n        });\n    }\n    \n    render(){\n        cont { num } = this.state;\n        return(\n            &lt;div className=&quot;Count&quot;&gt;\n                &lt;h1&gt; 카운터 입니다! &lt;/h1&gt;\n                &lt;button onClick={this.handleIncrease}&gt;+&lt;/button&gt;\n                &lt;div&gt; {num} &lt;/div&gt;\n                &lt;button onClick={this.handleDecrease}&gt;-&lt;/button&gt;\n            &lt;/div&gt;\n        );\n    }\n}\n\nexport default Hello;</code></pre>\n      </div>\n<p>위의 예제에서, state 값을 변경하기위하여 2개의 메소드(handleIncrease, handleDecrease)를 정의하였습니다. </p>\n<div class=\"gatsby-highlight\" data-language=\"react\">\n      <pre class=\"language-react\"><code class=\"language-react\">handleIncrease = () =&gt; {\n    this.setState((prevState) =&gt; {\n        return {\n            number: ++prevState.num\n        };\n    }, () =&gt; {\n        /* setState 직후에 이루어져야하는 작업*/\n    });\n}\n\nhandleDecrease = () =&gt; {\n    this.setState((prevState) =&gt; {\n        return {\n            number: --prevState.num\n        };\n    });\n}</code></pre>\n      </div>\n<p>이 메소드들을 살펴보면 state 값을 변경하기 위하여 **this.setState **를 사용한 것을 확인할 수 있습니다. 리액트에서 state 값을 변경할 경우 this.setState를 통한 변경만이 가능합니다. 또한, 순차적인 실행이 필요한 경우 위와 같이 call back스타일로 작성할 수 있습니다.</p>\n<p>이러한 setState가 호출되면 자동적으로 <strong>reredndering</strong>이 발생하여, 기존의 DOM에서 변경된 element만 rerendering되는 update 과정을 거치게됩니다. 그렇기에 state를 잘못 활용한다면 오히려 성능상의 비효율을 초래할 수 있습니다!</p>\n<p>덧붙여, 위의 메소드는 아래와 같은 방식으로도 정의할 수 있습니다. </p>\n<div class=\"gatsby-highlight\" data-language=\"react\">\n      <pre class=\"language-react\"><code class=\"language-react\">handleIncrease(){\n    this.setState({\n    \tnumber: this.state.number + 1\n    });\n}\n\nhandleIncrease(){\n    this.setState({\n    \tnumber: this.state.number - 1\n    });\n}</code></pre>\n      </div>\n<p>하지만, 위의 방식은 비동기적으로 작동하여 상태값이 제대로 업데이트되지 않을 수 있고, 메소드가 클릭 이벤트로 전달되는 과정에서 this의 연결이 끊겨 제대로 작동되지 않을 수 있기 때문에, arrow function을 사용한 방식을 추천드립니다.</p>\n<p>이번에는 render메소드에서 이벤트핸들러를 설정하는 부분을 살펴보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"react\">\n      <pre class=\"language-react\"><code class=\"language-react\">render(){\n    cont { num } = this.state;\n    return(\n        &lt;div className=&quot;Count&quot;&gt;\n            &lt;h1&gt; 카운터 입니다! &lt;/h1&gt;\n            &lt;button onClick={this.handleIncrease}&gt;+&lt;/button&gt;\n            &lt;div&gt; {num} &lt;/div&gt;\n            &lt;button onClick={this.handleDecrease}&gt;-&lt;/button&gt;\n        &lt;/div&gt;\n    );\n}</code></pre>\n      </div>\n<p>앞으로 우리가 리액트를 사용하면서 주의해야할 부분이 있습니다!</p>\n<ol>\n<li>\n<p>이벤트핸들러를 설정할 경우, HTML과 달리 이벤트의 이름은 항상 <strong>camelCase</strong>로 작성해주어야 합이다.</p>\n</li>\n<li>\n<p>이벤트핸들러 설정시, 함수자체를 전달해야합니다. 아래와 같이 작성할 경우, 버튼의 클릭 여부와 상관없이 렌더링될 때 마다이벤트핸들러가 작동되면서 무한 루프에 빠지게됩니다..</p>\n<div class=\"gatsby-highlight\" data-language=\"react\">\n      <pre class=\"language-react\"><code class=\"language-react\">&lt;button onClick={this.handleIncrease()}&gt;+&lt;/button&gt;</code></pre>\n      </div>\n</li>\n</ol>","excerpt":"1. Component 리액트는 ui를 재사용 가능한  컴포넌트  단위로 분리하여 작성합니다. 다시 말하면, 리액트의 모든 것은 컴포넌트 입니다! 컴포넌트는  render 메소드에서   JSX 를 통하여 작성된 단 하나 의 DOM element…","frontmatter":{"title":"1. React - component, props, state","date":"2018-12-05","tags":["react"],"keywords":["SW_P"]}}},"pageContext":{"slug":"/react1-post/","previous":{"fields":{"slug":"/algo-3-post/"},"frontmatter":{"title":"[BOJ 11559] Puyo Puyo","tags":["algorithm"],"published":true}},"next":{"fields":{"slug":"/algo-4-post/"},"frontmatter":{"title":"[BOJ 9207] 페그 솔리테어","tags":["algorithm"],"published":true}}}}