{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\n \n\n# [BOJ 9207 페그 솔리테어](https://www.acmicpc.net/problem/9207)\n\n```c++\n#include <stdio.h>\n#include <queue>\n#include <utility>\nusing namespace std;\n\nchar board[6][10];\nchar cp[6][10];\nint dx[] = {0, -1, 0, 1};\nint dy[] = {-1, 0, 1, 0};\nint p_num = 2147483647, origin_p;\n\nvoid dfs(int x, int y){\n    int ax, ay, i, j, k, p = 0;\n    \n    for(i = 0; i < 4; i++){\n        ax = x + dx[i];\n        ay = y + dy[i];\n        \n        if(ax >= 0 && ax < 5 && ay >= 0 && ay < 9 && cp[ax][ay] == 'o'){\n            if(ax + dx[i] >= 0 && ax + dx[i] < 5 && ay + dy[i] >= 0 && ay + dy[i] < 9\n               && cp[ax + dx[i]][ay + dy[i]] == '.'){\n                cp[ax+dx[i]][ay+dy[i]] = 'o';\n                cp[x][y] = '.';\n                cp[ax][ay] = '.';\n                \n                for(j = 0; j < 5; j++){\n                    for(k = 0; k < 9; k++){\n                        if(cp[j][k] == 'o'){\n                            dfs(j, k);\n                        }\n                    }\n                }\n                \n                cp[ax+dx[i]][ay+dy[i]] = '.';\n                cp[x][y] = 'o';\n                cp[ax][ay] = 'o';\n                \n            }\n            \n        }\n    }\n\n    for(j = 0; j < 5; j++){\n        for(k = 0; k < 9; k++){\n            if(cp[j][k] == 'o'){\n                p++;\n            }\n        }\n    }\n    \n    p_num = p_num < p ? p_num : p;\n    \n}\n\n\n\nvoid selectPin(queue<pair<int, int>> pin){\n    int i, j;\n    while(!pin.empty()){\n        dfs(pin.front().first, pin.front().second);\n        \n        for(i = 0; i < 5; i++){\n            for(j = 0; j < 9; j++){\n                cp[i][j] = board[i][j];\n            }\n        }\n        \n        pin.pop();\n    }\n}\n\nint main(int argc, const char * argv[]) {\n    int n, i, j;\n    queue<pair<int, int>> ret;\n    \n    scanf(\"%d\", &n);\n    \n    while(n--){\n        queue<pair<int, int>> pin;\n        p_num = 2147483647;\n\n        for(i = 0; i < 5; i++){\n            scanf(\"%s\", board[i]);\n        }\n        \n        for(i = 0; i < 5; i++){\n            for(j = 0; j < 9; j++){\n                cp[i][j] = board[i][j];\n                if(board[i][j] == 'o'){\n                    pin.push(pair<int, int>(i, j));\n                }\n            }\n        }\n        \n        origin_p = (int)pin.size();\n        \n        selectPin(pin);\n        \n        ret.push(pair<int, int>(p_num, origin_p-p_num));\n    }\n    \n    while(!ret.empty()){\n        printf(\"%d %d\\n\", ret.front().first, ret.front().second);\n        ret.pop();\n    }\n    \n    return 0;\n}\n```\n\n","fields":{"slug":"/algo-4-post/"},"frontmatter":{"title":"[BOJ 9207] 페그 솔리테어","published":true}}},{"node":{"rawMarkdownBody":"\n## 1. Component\n\n리액트는 ui를 재사용 가능한 **컴포넌트** 단위로 분리하여 작성합니다. 다시 말하면, 리액트의 모든 것은 컴포넌트 입니다!\n\n컴포넌트는  render 메소드에서  [JSX](https://reactjs.org/docs/introducing-jsx.html)를 통하여 작성된**단 하나**의 DOM element만을 반환해야합니다.\n\n예를 들면,\n\n```react\nconst ex1 = (\n\t<div> element1 </div>\n\t<div> element2 </div>\n);\n```\n\n이러한 경우 *JSX elements must be wrapped in an enclosing tag* 와같은 에러를 뱉어냅니다.\n\n따라서,\n\n```react\nconst ex1 = (\n\t<div>\n        <div> element1 </div>\n        <div> element2 </div>\n\t</div>\n);\n```\n\n이렇게 다른 태그로 감싸거나, [Fragment](https://reactjs.org/docs/fragments.html#keyed-fragments)를 활용해야 합니다.\n\n\n\n\n### 1) 클래스형 컴포넌트\n\n컴포넌트를 작성하는 방식은 클래스형 컴포넌트, 함수형 컴포넌트 2가지가 있습니다.\n\n먼저, 클래스형 컴포넌트에는 JSX로 이루어진 DOM Element를 반환하는 **render**함수가 꼭 있어야합니다.\n\n```react\nimport React, { Component } from 'react';\n\nclass Hello extends Component {\n    render(){\n        return(\n            <div className=\"Hello\">\n                <h1> Hello, BTTB66! </h1>\n            </div>\n        );\n    }\n}\n\nexport default Hello;\n```\n\n클래스형 컴포넌트는 props와 state, life-cycle 관련 메소드 모두 활용 가능합니다.\n\n\n\n\n### 2) 함수형 컴포넌트\n\n함수형 컴포넌트는 props만 사용이 가능합니다. state와 life-cycle 모두 활용할 수 없지만, 클래스형 컴포넌트에 비하여 속도가 빠르다는 장점이 있습니다. \n\n따라서, state나 life-cycle을 활용하지 않고 **자체기능 없이 그저 전달된 props만 렌더링 하는 경우**에는 함수형 컴포넌트를 활용하는 것이 좋습니다.\n\n```react\nimport React from 'react';\n\n/*비구조 할당방식 활용*/\ncont Hello = ({name})=>{\n    return(\n        <div className=\"Hello\">\n            <h1> Hello, {name}! </h1>\n        </div>\n    );\n}\n\nexport default Hello;\n```\n\n함수형 컴포넌트 활용시, 함수의 매개밴수를 통하여 props에 접근 가능합니다.\n\n\n\n\n\n## 2. Props, state\n\n리액트의 컴포넌트에서 다루는 데이터는 props와 state 이 2가지로 나누어집니다.  간단히 설명하면, props는 부모로부터 전해받는 변경이 불가능한 데이터 입니다. 이와 달리, state는 컴포넌트의 내부에서 선언하며, 변경이 가능합니다.\n\n\n\n### 1) props\n\n```react\nimport React, { Component } from 'react';\n\nclass Hello extends Component {\n    render(){\n        cont { name } = this.props;\n        return(\n            <div className=\"Hello\">\n                <h1> Hello, {name}! </h1>\n            </div>\n        );\n    }\n}\n\nexport default Hello;\n```\n\n부모로부터 전달받은 props값은 this키워드를 통하여 접근이 가능합니다. 위의 예제에서는 비구조할당 방식을 활용하여 props의 name에 접근하였습니다.\n\n이러한 props는 아래와 같은 방식으로 전달할 수 있습니다.\n\n```react\nimport React, {Component} from 'react';\nimport Hello from './Hello';\n\nclass App extends Component{\n    render(){\n        return (\n        \t<Hello name=\"BTTB66\" />\n        );\n    }\n}\n\nexport default App;\n```\n\n만약, 부모 컴포넌트에서 props 데이터를 실수로 전달하지 않을 경우, 자식 컴포넌트에서 props에 접근하면 오류가 발생합니다.\n\n이러한 오류를 막기 위하여 아래와 같이 **default props**를 설정해주어야 합니다!\n\n```react\nimport React, { Component } from 'react';\n\nclass Hello extends Component {\n    static defaultProps= {\n        name: '이름'\n    }\n    render(){\n        return(\n            <div className=\"Hello\">\n                <h1> Hello, BTTB66! </h1>\n            </div>\n        );\n    }\n}\n\nexport default Hello;\n```\n\n\n\n\n\n### 2) state\n\nprops와 달리, 동적인 데이터를 다루어야할 경우 state를 활용할 수 있습니다. \n\nstate를 사용할 경우, class field를 활용하면 훨씬 편리해집니다. 때문에 EcmaScript6의 [class field](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes)에 대한 이해가 선행되는 것이 좋습니다.\n\n```react\nimport React, { Component } from 'react';\n\nclass Count extends Component {\n    //state 정의\n    state = {\n        num : 0\n    }\n\t\n    handleIncrease = () => {\n        this.setState((prevState) => {\n            return {\n                number: ++prevState.num\n            };\n        });\n    }\n\n    handleDecrease = () => {\n        this.setState((prevState) => {\n            return {\n                number: --prevState.num\n            };\n        });\n    }\n    \n    render(){\n        cont { num } = this.state;\n        return(\n            <div className=\"Count\">\n                <h1> 카운터 입니다! </h1>\n                <button onClick={this.handleIncrease}>+</button>\n                <div> {num} </div>\n                <button onClick={this.handleDecrease}>-</button>\n            </div>\n        );\n    }\n}\n\nexport default Hello;\n```\n\n\n\n위의 예제에서, state 값을 변경하기위하여 2개의 메소드(handleIncrease, handleDecrease)를 정의하였습니다. \n\n```react\nhandleIncrease = () => {\n    this.setState((prevState) => {\n        return {\n            number: ++prevState.num\n        };\n    }, () => {\n        /* setState 직후에 이루어져야하는 작업*/\n    });\n}\n\nhandleDecrease = () => {\n    this.setState((prevState) => {\n        return {\n            number: --prevState.num\n        };\n    });\n}\n```\n\n이 메소드들을 살펴보면 state 값을 변경하기 위하여 **this.setState**를 사용한 것을 확인할 수 있습니다. 리액트에서 state 값을 변경할 경우 this.setState를 통한 변경만이 가능합니다. 또한, 순차적인 실행이 필요한 경우 위와 같이 call back스타일로 작성할 수 있습니다.\n\n이러한 setState가 호출되면 자동적으로 **reredndering**이 발생하여, 기존의 DOM에서 변경된 element만 rerendering되는 update 과정을 거치게됩니다. 그렇기에 state를 잘못 활용한다면 오히려 성능상의 비효율을 초래할 수 있습니다!\n\n\n\n덧붙여, 위의 메소드는 아래와 같은 방식으로도 정의할 수 있습니다. \n\n```react\nhandleIncrease(){\n    this.setState({\n    \tnumber: this.state.number + 1\n    });\n}\n\nhandleIncrease(){\n    this.setState({\n    \tnumber: this.state.number - 1\n    });\n}\n```\n\n하지만, 위의 방식은 비동기적으로 작동하여 상태값이 제대로 업데이트되지 않을 수 있고, 메소드가 클릭 이벤트로 전달되는 과정에서 this의 연결이 끊겨 제대로 작동되지 않을 수 있기 때문에, arrow function을 사용한 방식을 추천드립니다.\n\n\n\n이번에는 render메소드에서 이벤트핸들러를 설정하는 부분을 살펴보겠습니다.\n\n```react\nrender(){\n    cont { num } = this.state;\n    return(\n        <div className=\"Count\">\n            <h1> 카운터 입니다! </h1>\n            <button onClick={this.handleIncrease}>+</button>\n            <div> {num} </div>\n            <button onClick={this.handleDecrease}>-</button>\n        </div>\n    );\n}\n```\n\n앞으로 우리가 리액트를 사용하면서 주의해야할 부분이 있습니다!\n\n1. 이벤트핸들러를 설정할 경우, HTML과 달리 이벤트의 이름은 항상 **camelCase**로 작성해주어야 합이다.\n\n2. 이벤트핸들러 설정시, 함수자체를 전달해야합니다. 아래와 같이 작성할 경우, 버튼의 클릭 여부와 상관없이 렌더링될 때 마다이벤트핸들러가 작동되면서 무한 루프에 빠지게됩니다..\n\n   ```react\n   <button onClick={this.handleIncrease()}>+</button>\n   ```\n\n","fields":{"slug":"/react1-post/"},"frontmatter":{"title":"1. React - component, props, state","published":true}}},{"node":{"rawMarkdownBody":"\n \n\n# [BOJ 11559 Puyo Puyo](https://www.acmicpc.net/problem/11559)\n\n```c++\n#include <stdio.h>\n#include <queue>\n#include <utility>\nusing namespace std;\n\nchar map[13][7];\nint visit[13][7];\nint dx[] = {0, -1, 0, 1};\nint dy[] = {-1, 0, 1, 0};\nint ret = 0;\n\nvoid setPuyo(){\n    int i, j, cnt = 0;\n    ret++;\n\n    for(j = 0; j < 6; j++){\n        cnt = 0;\n        for(i = 11; i >= 0; i--){\n            if(map[i][j] == '.')\n                cnt++;\n            if(map[i][j] != '.' && cnt != 0){\n                map[i+cnt][j] = map[i][j];\n                map[i][j] = '.';\n            }\n        }\n    }\n}\n\nvoid bombPuyo(queue<pair<int, int>> q){\n    int x, y;\n    \n    while(!q.empty()){\n        x = q.front().first;\n        y = q.front().second;\n        \n        map[x][y] = '.';\n        q.pop();\n    }\n}\n\nbool checkPuyo(int a, int b){\n    queue<pair<int,int>> q;\n    queue<pair<int,int>> q2;\n    int i, j, x, y, ax, ay, cnt = 1;\n    \n    q.push(pair<int, int>(a, b));\n    q2.push(pair<int, int>(a, b));\n    visit[a][b] = 1;\n    \n    while(!q.empty()){\n        x = q.front().first;\n        y = q.front().second;\n        q.pop();\n        \n        for(i = 0; i < 4; i++){\n            ax = dx[i] + x;\n            ay = dy[i] + y;\n            \n            if(ax >= 0 && ax < 12 && ay >= 0 && ay < 6 && map[ax][ay] == map[a][b] && visit[ax][ay] == 0){\n                cnt++;\n                q.push(pair<int, int>(ax, ay));\n                q2.push(pair<int, int>(ax, ay));\n                visit[ax][ay] = 1;\n            }\n        }\n\n    }\n    for(i = 0; i < 12; i++){\n        for(j = 0; j < 6; j++)\n            visit[i][j] = 0;\n    }\n\n    if(cnt >= 4){\n        bombPuyo(q2);\n        return true;\n    }\n    return false;\n}\n\n\nvoid selectPuyo(){\n    int i, j;\n    bool flag = false;\n    \n    for(i = 11; i >= 0; i--){\n        for(j = 0; j < 6; j++){\n            if(map[i][j] != '.'){\n                if(checkPuyo(i, j))\n                    flag = true;\n            }\n        }\n    }\n    \n    if(flag){\n        setPuyo();\n        selectPuyo();\n    }\n\n}\n\nint main(int argc, const char * argv[]) {\n    int i;\n    \n    for(i = 0; i < 12; i++){\n        scanf(\"%s\", map[i]);\n    }\n\n    selectPuyo();\n    \n    printf(\"%d\", ret);\n    \n    return 0;\n}\n\n```\n\n","fields":{"slug":"/algo-3-post/"},"frontmatter":{"title":"[BOJ 11559] Puyo Puyo","published":true}}},{"node":{"rawMarkdownBody":"\n \n\n# [BOJ 6603 로또](https://www.acmicpc.net/problem/6603)\n\n```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException{\n\t\t// TODO Auto-generated method stub\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint[] arr;\n\t\tStringTokenizer st = null;\n\t\twhile(true){\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tint n = Integer.parseInt(st.nextToken());\n\t\t\t\n\t\t\tif(n == 0)\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tarr = new int[n];\n\t\t\tfor(int i = 0;i < n; i++){\n\t\t\t\tarr[i] = Integer.parseInt(st.nextToken());\n\t\t\t}\n\t\t\t\n\t\t\tgetLotto(arr, \"\", n, 0, 0);\n\t\t\tSystem.out.println();\n\t\t}\n\t\t\n\t\tbr.close();\n\t}\n\t\n\tpublic static void getLotto(int[] arr, String lotto, int size, int n, int cnt){\n\t\tif(cnt == 6){\n\t\t\tSystem.out.println(lotto);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfor(int i = n; i < size; i++){\n\t\t\tgetLotto(arr, lotto+arr[i]+ \" \", size, i + 1, cnt+1);\n\t\t}\n\t}\n\n}\n```\n\n","fields":{"slug":"/algo-2-post/"},"frontmatter":{"title":"[BOJ 6603] 로또","published":true}}},{"node":{"rawMarkdownBody":"\n# [BOJ 14620 꽃길](https://www.acmicpc.net/problem/14620)\n\n```c++\n#include <iostream>\n#include <stdio.h>\nusing namespace std;\n\nint map[11][11];\nint visit[11][11];\nint price = 2147483647, len;\n\n\n\nvoid dfs(int cnt, int pr){\n    int dx[4] = {0, -1, 0, 1};\n    int dy[4] = {-1, 0, 1, 0};\n    int i, j, k, ax, ay, p;\n    bool flag;\n    \n    if(cnt == 0){\n        price = price < pr ? price : pr;\n        return;\n    }\n    \n    for(i = 1; i < len; i++){\n        for(j = 1; j < len; j++){\n            flag = true;\n            if(visit[i][j] == 1)\n                continue;\n            for(k = 0; k < 4; k++){\n                ax = i + dx[k];\n                ay = j + dy[k];\n                if(ax < 0 || ax >= len || ay < 0 || ay >= len || visit[ax][ay] == 1){\n                    flag = false;\n                    break;\n                }\n            }\n            \n            if(!flag)\n                continue;\n            \n            visit[i][j] = 1;\n            p = map[i][j];\n            for(k = 0; k < 4; k++){\n                ax = i + dx[k];\n                ay = j + dy[k];\n                visit[ax][ay] = 1;\n                p += map[ax][ay];\n            }\n            \n            dfs(cnt-1, pr+p);\n            \n            visit[i][j] = 0;\n            for(k = 0; k < 4; k++){\n                ax = i + dx[k];\n                ay = j + dy[k];\n                visit[ax][ay] = 0;\n            }\n        }\n    }\n}\n\nint main(int argc, const char * argv[]) {\n\n    int i = 0, j = 0;\n    scanf(\"%d\", &len);\n    \n    for(i = 0; i < len; i++){\n        for(j = 0; j < len; j++){\n            scanf(\"%d\", &map[i][j]);\n        }\n    }\n\n    dfs(3, 0);\n    \n    printf(\"%d\", price);\n    return 0;\n}\n\n```\n\n최적화 필요","fields":{"slug":"/algo-post/"},"frontmatter":{"title":"[BOJ 14620] 꽃길","published":true}}},{"node":{"rawMarkdownBody":"\n기본적인 설정, 포스트 작성 예시는 Documents를 확인하세요.\n\n- [Documnets](https://github.com/junhobaik/junhobaik.github.io/wiki/Documents)\n- [Github Repository](https://github.com/junhobaik/junhobaik.github.io)\n- [Demo blog](https://junhobaik.github.io/)\n","fields":{"slug":"/first-post/"},"frontmatter":{"title":"First Post, README","published":true}}}]}},"pageContext":{}}